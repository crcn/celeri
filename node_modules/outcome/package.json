{
  "name": "outcome",
  "description": "DRY error handling",
  "author": {
    "name": "Craig Condon"
  },
  "repository": {},
  "version": "0.0.18",
  "engines": {},
  "dependencies": {},
  "devDependencies": {
    "expect.js": "0.2.x",
    "mocha": "1.8.x"
  },
  "scripts": {
    "test": "mocha --reporter min"
  },
  "main": "./lib/index.js",
  "readme": "\n\nOutcome.js is a simple flow-control library which wraps your `.callback(err, result)` functions. \n\n### Motiviation\n\n- Write less code for handling errors.\n- Easier to maintain.\n- Keep error handling code separate. \n\n\n\n### Basic Example\n\nHere's the traditional method of handling errors:\n\n```javascript\n\nvar fs = require('fs');\n\nfunction doSomething(path, callback) {\n\n\tfs.realpath(path, onRealPath);\n\n\tfunction onRealPath(err, path) {\n\t\tif(err) return callback(err);\n\t\tfs.lstat(path, onStat);\n\t}\n\n\tfunction onStat(err, stats) {\n\t\tif(err) return callback(err);\n\t\tcallback(err, stats);\n\t}\n\n}\n\ndoSomething('/path/to/something', function(err, result) {\n\t\n\t//inline with result handling - yuck\n\tif(err) {\n\n\t\t//do something with error\n\t\treturn;\n\t}\n\n\t//do something with result\n})\n```\n\nThe outcome.js way:\n\n```javascript\n\nvar fs  = require('fs'),\noutcome = require('outcome');\n\nfunction doSomething(path, callback) {\n\n\t//wrap the callback around an error handler so any errors in *this* function\n\t//bubble back up to the callback - I'm lazy and I don't wanna write this stuff...\n\tvar on = outcome.error(callback);\n\n\t//on success, call onRealPath. Any errors caught will be sent back\n\t//automatically\n\tfs.realpath(path, on.success(onRealPath));\n\n\tfunction onRealPath(path) {\n\n\t\t//ONLY call onStat if we've successfuly grabbed the file stats\n\t\tfs.lstat(path, on.success(onStat));\n\t}\n\n\tfunction onStat(stats) {\n\n\t\t//no errors, so send a response back\n\t\tcallback(null, stats);\n\t}\n}\n\n\nvar on = outcome.error(function(error) {\n\t//do something with error\n}));\n\ndoSomething('/path/to/something', on.success(function(response) {\n\t//do something with result\n}));\n\n```\n\n## API\n\n### outcome(listeners)\n\n- `listeners` - Object of listeners you want to attach to outcome.\n\n```javascript\n\nvar onResult = outcome({\n\t\n\t//called when an error is caught\n\terror: function(error) {\n\t\t\n\t},\n\n\t//called when an error is NOT present\n\tsuccess: function(result, thirdParam) {\n\t\t\n\t},\n\n\t//called back when an error, or result is present\n\tcallback: function(err, result, thirdParam) {\n\t\t\n\t}\n})\n\n```\n\nAs shown in the example above, you can also wrap-around an existing callback:\n\n```javascript\nvar onResult = outcome.error(function(error) {\n\t\n}).\nsuccess(function(result, thirdParam) {\n\t\n}).\ncallback(function(error, result, thirdParam) {\n\t\n});\n```\n\n\nBy default, any unhandled errors are thrown. To get around this, you'll need to listen for an `unhandledError`:\n\n```javascript\noutcome.on('unhandledError', function(error) {\n\t//report bugs here..., then throw again.\n});\n\n\n//fails\nfs.stat('s'+__filename, outcome.success(function() {\n\n\n});\n```\n\n\n\n### .callback()\n\nCalled when on error/success. `Same as function(err, data) { }`\n\nHere's a redundant example:\n\n```javascript\n\nfs.stat(__filename, outcome.error(function(err) {\n\t//handle error\n}).success(function(data) {\n\t//handle result\n}.callback(function(err, result) {\n\t//called on fn complete regardless if there's an error, or success\n}));\n\n```\n\n### .success(fn)\n\nCalled on Success.\n\n```javascript\nvar onOutcome = outcome.success(function(data, anotherParam, andAnotherParam) {\n\t//handle success data\n});\n\nonOutcome(null, \"success!\", \"more data!\", \"more results..\");\n```\n\n### .error(fn)\n\nCalled on error.\n\n```javascript\n\nvar onOutcome = outcome.error(function(err) {\n\t\n});\n\nonOutcome(new Error(\"something went wrong...\")); \n```\n\n### .handle(fn)\n\nCustom response handler\n\n```javascript\n\noutcome.handle(function(response) {\n\t\n\tif(response.errors) this.error(response);\n\tif(response.data) this.success(response);\n});\n\n```\n\n\n## CoffeeScript Example\n\n```coffeescript\n\noutcome = require \"outcome\"\n\ndoSomething(path, callback) ->\n\t\n\ton = outcome.error callback\n\n\t# first get the realpath\n\tfs.realpath path, on.success onRealPath\n\n\t# on real path, get stats\n\tonRealPath(path) -> fs.lstat path, on.success onStat\n\n\t# on stat, finish\n\tonStat(stats) -> callback null, stats\n\n\n# call do something\ndoSomething '/path/to/something', outcome \n\n\tsuccess: (statis) ->\n\t\t# do something\n\n\terror: (error) ->\n\t\t# do something else\n\n\n```\n\n\n### Note\n\nCalling `.error()`, `.success()`, `.callback()` generates a new function which copies the previous listeners. \nCheckout [fs-test](outcome.js/blob/master/examples/fs-test.js) in the [examples](outcome.js/blog/master/examples) folder.\n",
  "readmeFilename": "README.md",
  "_id": "outcome@0.0.18",
  "_from": "outcome@0.0.x"
}
